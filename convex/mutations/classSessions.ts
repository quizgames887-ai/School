import { mutation } from "../_generated/server";
import { v } from "convex/values";

// Helper to get dates for a specific day of week within a date range
function getDatesForDayOfWeek(
  startDate: Date,
  endDate: Date,
  dayOfWeek: number
): Date[] {
  const dates: Date[] = [];
  const current = new Date(startDate);
  
  // Adjust to the first occurrence of the day of week
  const currentDay = current.getDay();
  const daysUntilTarget = (dayOfWeek - currentDay + 7) % 7;
  current.setDate(current.getDate() + daysUntilTarget);
  
  // Collect all dates for this day of week within range
  while (current <= endDate) {
    dates.push(new Date(current));
    current.setDate(current.getDate() + 7);
  }
  
  return dates;
}

// Format date as ISO string (YYYY-MM-DD)
function formatDateISO(date: Date): string {
  const year = date.getFullYear();
  const month = String(date.getMonth() + 1).padStart(2, "0");
  const day = String(date.getDate()).padStart(2, "0");
  return `${year}-${month}-${day}`;
}

// Sync class sessions from teacher schedules (lectures)
export const syncFromTeacherSchedules = mutation({
  args: {
    startDate: v.string(), // ISO date string (YYYY-MM-DD)
    endDate: v.string(), // ISO date string (YYYY-MM-DD)
    academicYear: v.string(),
    teacherId: v.optional(v.id("teachers")), // Optional: sync for specific teacher only
  },
  handler: async (ctx, args) => {
    const start = new Date(args.startDate);
    const end = new Date(args.endDate);
    
    // Get all recurring lectures for the academic year
    let lectures = await ctx.db
      .query("lectures")
      .withIndex("by_academic_year", (q) => q.eq("academicYear", args.academicYear))
      .collect();
    
    // Filter to only recurring lectures
    lectures = lectures.filter((l) => l.recurring);
    
    // If teacherId is provided, filter to that teacher
    if (args.teacherId) {
      lectures = lectures.filter((l) => l.teacherId === args.teacherId);
    }
    
    // Get existing class sessions in the date range
    const existingSessions = await ctx.db
      .query("classSessions")
      .withIndex("by_academic_year", (q) => q.eq("academicYear", args.academicYear))
      .collect();
    
    // Filter existing sessions by date range
    const existingSessionsInRange = existingSessions.filter((session) => {
      const sessionDate = new Date(session.date);
      return sessionDate >= start && sessionDate <= end;
    });
    
    // Create a lookup map for existing sessions: key = teacherId_sectionId_date_time
    const existingSessionMap = new Map<string, boolean>();
    existingSessionsInRange.forEach((session) => {
      const key = `${session.teacherId}_${session.sectionId}_${session.date}_${session.time}`;
      existingSessionMap.set(key, true);
    });
    
    let created = 0;
    let skipped = 0;
    
    // Process each lecture
    for (const lecture of lectures) {
      // Skip lectures without sectionId (legacy data)
      if (!lecture.sectionId) {
        skipped++;
        continue;
      }
      
      // Get the lesson to find the curriculum (subject)
      const lesson = await ctx.db.get(lecture.lessonId);
      if (!lesson) {
        skipped++;
        continue;
      }
      
      const unit = await ctx.db.get(lesson.unitId);
      if (!unit) {
        skipped++;
        continue;
      }
      
      // The curriculum ID is the subject ID
      const curriculumId = unit.subjectId;
      
      // Get all dates for this lecture's day of week within the range
      const dates = getDatesForDayOfWeek(start, end, lecture.dayOfWeek);
      
      for (const date of dates) {
        const dateStr = formatDateISO(date);
        const key = `${lecture.teacherId}_${lecture.sectionId}_${dateStr}_${lecture.startTime}`;
        
        // Skip if session already exists
        if (existingSessionMap.has(key)) {
          skipped++;
          continue;
        }
        
        // Create the class session
        await ctx.db.insert("classSessions", {
          sectionId: lecture.sectionId,
          curriculumId: curriculumId,
          teacherId: lecture.teacherId,
          date: dateStr,
          time: lecture.startTime,
          endTime: lecture.endTime,
          academicYear: args.academicYear,
          periodId: lecture.periodId,
          recurring: true,
          dayOfWeek: lecture.dayOfWeek,
        });
        
        created++;
        // Add to map to prevent duplicates within same sync
        existingSessionMap.set(key, true);
      }
    }
    
    return {
      created,
      skipped,
      message: `Created ${created} class sessions, skipped ${skipped} (already exist or invalid)`,
    };
  },
});

// Clear auto-generated class sessions for a date range (useful for re-syncing)
export const clearAutoGenerated = mutation({
  args: {
    startDate: v.string(),
    endDate: v.string(),
    academicYear: v.string(),
    teacherId: v.optional(v.id("teachers")),
  },
  handler: async (ctx, args) => {
    const start = new Date(args.startDate);
    const end = new Date(args.endDate);
    
    // Get all class sessions for the academic year
    let sessions = await ctx.db
      .query("classSessions")
      .withIndex("by_academic_year", (q) => q.eq("academicYear", args.academicYear))
      .collect();
    
    // Filter to recurring sessions in date range
    sessions = sessions.filter((session) => {
      if (!session.recurring) return false;
      const sessionDate = new Date(session.date);
      if (sessionDate < start || sessionDate > end) return false;
      if (args.teacherId && session.teacherId !== args.teacherId) return false;
      return true;
    });
    
    // Delete the sessions
    let deleted = 0;
    for (const session of sessions) {
      await ctx.db.delete(session._id);
      deleted++;
    }
    
    return {
      deleted,
      message: `Deleted ${deleted} auto-generated class sessions`,
    };
  },
});

export const create = mutation({
  args: {
    sectionId: v.id("sections"),
    curriculumId: v.id("subjects"),
    teacherId: v.id("teachers"),
    date: v.string(),
    time: v.string(),
    endTime: v.optional(v.string()),
    academicYear: v.string(),
    periodId: v.optional(v.id("periods")),
    recurring: v.optional(v.boolean()),
    dayOfWeek: v.optional(v.number()),
  },
  handler: async (ctx, args) => {
    // If periodId is provided, validate it exists and sync time
    let finalTime = args.time;
    let finalEndTime = args.endTime;
    
    if (args.periodId) {
      const period = await ctx.db.get(args.periodId);
      if (!period) {
        throw new Error("Period not found");
      }
      if (period.isBreak) {
        throw new Error("Cannot assign class session to a break period");
      }
      // Sync times from period if periodId is provided
      finalTime = period.startTime;
      finalEndTime = period.endTime;
    }
    
    // Validate times if endTime is provided
    if (finalEndTime && finalTime >= finalEndTime) {
      throw new Error("Start time must be before end time");
    }
    
    return await ctx.db.insert("classSessions", {
      sectionId: args.sectionId,
      curriculumId: args.curriculumId,
      teacherId: args.teacherId,
      date: args.date,
      time: finalTime,
      endTime: finalEndTime,
      academicYear: args.academicYear,
      periodId: args.periodId,
      recurring: args.recurring ?? false,
      dayOfWeek: args.dayOfWeek,
    });
  },
});

export const update = mutation({
  args: {
    id: v.id("classSessions"),
    sectionId: v.optional(v.id("sections")),
    curriculumId: v.optional(v.id("subjects")),
    teacherId: v.optional(v.id("teachers")),
    date: v.optional(v.string()),
    time: v.optional(v.string()),
    endTime: v.optional(v.string()),
    academicYear: v.optional(v.string()),
    periodId: v.optional(v.id("periods")),
    recurring: v.optional(v.boolean()),
    dayOfWeek: v.optional(v.number()),
  },
  handler: async (ctx, args) => {
    const { id, ...updates } = args;
    const existing = await ctx.db.get(id);
    
    if (!existing) {
      throw new Error("Class session not found");
    }
    
    // If periodId is being set/updated, validate it and sync times
    if (updates.periodId !== undefined) {
      if (updates.periodId) {
        const period = await ctx.db.get(updates.periodId);
        if (!period) {
          throw new Error("Period not found");
        }
        if (period.isBreak) {
          throw new Error("Cannot assign class session to a break period");
        }
        // Sync times from period
        updates.time = period.startTime;
        updates.endTime = period.endTime;
      }
    }
    
    // Validate times if being updated
    if (updates.time !== undefined || updates.endTime !== undefined) {
      const time = updates.time ?? existing.time;
      const endTime = updates.endTime ?? existing.endTime;
      
      if (endTime && time >= endTime) {
        throw new Error("Start time must be before end time");
      }
    }
    
    await ctx.db.patch(id, updates);
    return id;
  },
});

export const deleteClassSession = mutation({
  args: { id: v.id("classSessions") },
  handler: async (ctx, args) => {
    await ctx.db.delete(args.id);
    return args.id;
  },
});
